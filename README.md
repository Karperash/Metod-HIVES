## HIVES — пример из статьи и JSON‑интерфейс

Этот репозиторий содержит **реализацию метода HIVES** (Hierarchical Voting-based Evaluation System) для группового выбора альтернатив и пример, повторяющий численный расчёт из статьи:

- `HIVES method for group decision-making` (таблицы с кандидатами и весами критериев).

Код написан на Python и читает **входные данные из JSON**, поэтому легко адаптируется под другие задачи.

---

### Структура проекта

- **`hives_method.py`** — реализация метода HIVES:
  - `score_bell_column` — функция Score Bell для одного критерия;
  - `expand_by_influence` — «раздувание» матрицы экспертов по их влиянию;
  - `hives` — вычисление весов критериев `γ` и промежуточных величин;
  - `hives_rank` — итоговая оценка и ранжирование альтернатив.
- **`models.py`**
  - `Criterion` — критерий (имя, направление оптимизации);
  - `DecisionMaker` — лицо, принимающее решение (матрица оценок альтернатив);
  - `Expert` — эксперт, задающий веса критериев (одна строка матрицы `W`);
  - `GroupParameters` — параметры задачи (пока не используются в расчётах);
  - `DecisionProblem` — объединяет альтернативы, критерии, ЛПР и экспертов, даёт:
    - `aggregated_performance()` — агрегированная матрица `A`;
    - `weights_matrix()` — матрица весов критериев `W`.
- **`json_input.py`** — чтение данных из JSON в объект `DecisionProblem`.
- **`main.py`** — точка входа: загружает JSON и печатает результаты HIVES.
- **`1.py`** — короткий скрипт‑обёртка: запускает `main.py` с файлом `input.json`.
- **`input.json`** — пример входных данных, соответствующий таблицам из статьи.

---

### Формат входного JSON

Файл `input.json` имеет следующую структуру:

```json
{
  "alternatives": ["A1", "A2", "..."],
  "criteria": [
    { "name": "c1", "type": "positive" },
    { "name": "c2", "type": "positive" },
    "...": {}
  ],
  "dms": [
    {
      "id": "DM1",
      "scores": [
        [11, 22, 16, 69, 67, 16],
        [92, 72, 10, 31, 45, 36],
        "... more rows ..."
      ]
    }
  ],
  "experts": [
    { "id": "E1", "weights": [23,  8, 14, 30, 15, 10] },
    { "id": "E2", "weights": [10,  9,  7, 45, 20,  9] },
    "... more experts ..."
  ]
}
```

- **`alternatives`** — список альтернатив (кандидатов) `A1…Ak`.
- **`criteria`** — список критериев `c1…cn`, поле `type` может быть `positive` или `negative` (в текущей реализации знак критерия ещё не учитывается, все считаются «больше — лучше»).
- **`dms[*].scores`** — матрица **`A` (альтернатива × критерий)** для каждого ЛПР. В примере используется одна матрица из таблицы 2 статьи.
- **`experts[*].weights`** — строки **матрицы весов критериев `W`** (таблица 3 статьи). Именно по этой матрице вычисляются веса критериев `γ`.

Если блок `experts` опустить, код автоматически построит равномерные веса критериев.

---

### Что считает программа

При запуске:

1. Из `input.json` загружаются:
   - матрица альтернатив `A` (таблица решений);
   - матрица весов критериев `W` (эксперты и их веса критериев).
2. По методу HIVES вычисляются:
   - **сырые веса критериев `γ`**;
   - **нормированные веса критериев `γ'`** (сумма = 100%);
   - **итоговый балл каждой альтернативы**;
   - **ранжирование альтернатив** по убыванию качества.

В приложенном примере результат по `γ` и `γ'` совпадает с приведёнными в статье значениями:

- \( \gamma_j \approx \{21.25,\; 12.14,\; 11.34,\; 23.50,\; 16.40,\; 10.18\} \)
- \( \gamma'_j \approx \{22.41,\; 12.80,\; 11.96,\; 24.78,\; 17.30,\; 10.74\} \)

---

### Установка и запуск

1. Установите зависимости (нужен Python 3.10+ и NumPy):

```bash
pip install numpy
```

2. Перейдите в каталог проекта и запустите:

```bash
cd "Пархоменко Методы принятия решений/1.6"
python main.py input.json
```

Или через обёртку:

```bash
python 1.py
```

---

### Вывод программы

Пример вывода:

```text
Сырые веса критериев γ:
[21.25 12.14 11.34 23.5  16.4  10.18]

Нормированные веса критериев γ' (в сумме = 100):
[22.41 12.8  11.96 24.78 17.3  10.74]

Итоговые баллы альтернатив:
A1: ...
A2: ...
...

Ранжирование альтернатив (1-based):
[ ... ]
```

Вы можете:

- менять `input.json`, чтобы анализировать другие наборы альтернатив и весов;
- добавлять несколько ЛПР в блок `dms` — оценки будут агрегированы усреднением.

---

### Как адаптировать под свою задачу

- **Измените альтернативы и их оценки** в блоке `dms[*].scores`.
- **Измените веса критериев** в блоке `experts[*].weights`, если хотите задать другую матрицу `W`.
- При необходимости можно доработать:
  - учёт отрицательных критериев (`type: "negative"`);
  - иной способ агрегации ЛПР в `DecisionProblem.aggregated_performance`.

Код максимально изолирован по модулям, поэтому его удобно расширять и использовать в других проектах.


